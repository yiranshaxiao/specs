6809 MPU OPERATION
==================

During normal operation, the MPU fetches an instruction from memory =
and then=20 executes the requested function. This sequence begins after
RESET and is = repeated indefinitely unless altered by a special
instruction or = hardware=20 occurrence. Software instructions that
alter normal MPU operation are: = SWI,=20 SWI2, SWI3, CWAI, RTI, and
SYNC. An interrupt or !HALT input can also = alter the=20 normal
execution of instructions Figure 14 is the flowchart for the = MC6809E.

> [**FIGURE 10 - CLOCK=20
> GENERATOR**](3D"http://www.howell1964.freeserve.co.uk/parts/6809fig10.png")

> NOTE: If optional circuit is not included the CLR and PRE inputs of =
> U2 and=20 U3 must be tied high.
>
> [**FIGURE 11 - READ-MODIFY-WRITE INSTRUCTION = EXAMPLE (ASL=20
> EXTENDED
> INDIRECT)**](3D"http://www.howell1964.freeserve.co.uk/parts/6809fig11")

ADDRESSING MODES
----------------

The basic instructions of any computer are greatly enhanced by the =
presence=20 of powerful addressing modes. The MC6809E has the most
complete set of=20 addressing modes available on any microcomputer. For
example, the = MC6809E has 59=20 basic instructions; however, it
recognizes 1464 different variations of=20 instructinns and addressing
modes. The addressing modes support modern=20 programming techniques.
The following addressing modes are available on = the=20 MC6809E:

> Inherent (Includes = Accumulator)\
> Immediate\
> Extended\
> Extended=20 Indirect\
> Direct\
> Register\
> Indexed\
> Zero-Offset\
> Constant=20 Oftset\
> Accumulator Qffset\
> Auto Increment Decrement\
> Indexed=20 Indirect\
> Relative\
> Short Long Relative Branching\
> Program = Counter=20 Relative Addressing

INHERENT (INCLUDES ACCUMULATOR)
-------------------------------

In this addressing mode, the opcode of the instruction contains all =
the=20 address information necessary. Examples of inherent addressing
are: ABX, = DAA,=20 SWI, ASRA, and CLRB.

IMMEDIATE ADDRESSING
--------------------

In immediate addressing, the effective address of the data is the =
location=20 immediatelv following the opcode (i.e., the data to be used
in the = instruction=20 immediately following the opcode at the
instruction). The MC6809E uses = both 8-=20 and 16-bit immediate values
depending on the size of argument specified = by the=20 opcode. Examples
of instructions with immediate addressing are:

>     LDA    #$20
>     LDX #$F000
>     LDY #CAT

> NOTE\
> \# signifies immediate addressing; \
> \$ signifies = hexadecimal value=20 to the MC6809 assembler.

EXTENDED ADDRESSING
-------------------

In extended addressing, the contents of the two bytes immediately =
following=20 the opcode fully specify the 16-bit effective address used
by the = instruction.=20 Note that the address generated by an extended
instruction defines an = absolute=20 address and is not position
independent. Examples of extended addressing = include:

>     LDA    CAT=20
>     STX MOUSE=20
>     LDD $2000

EXTENDED INDIRECT
-----------------

As a special case of indexed addressing (discussed below), one level =
of=20 indirection may be added to extended addressing. In extended
indirect, = the two=20 bytes following the postbyte of an indexed
instruction contain the = address of=20 the data.

>     LDA    [CAT]
>     LDX [$FFFE]
>     STU [DOG]

DIRECT ADDRESSING
-----------------

Direct addressing is similar to extended addressing except that only =
one byte=20 of address tollows the opcode. This byte specifies the lower
eight bits = of the=20 address to be used. The upper eight bits of the
address are supplied by = the=20 dira.t page register. Since only one
byte of address is required in = direct=20 addressing, this mode
requires less memory and exe-cutes taster than = extended=20 addressing.
Of course. only 256 locations (one page) can be accessed = without=20
redefining the contents of the DP register. Since the DP register is set
= to \$00=20 on reset, direct addressing on the MC6809E is upward
compatible with = direct=20 addressing on the M6800. Indirection is not
allowed in direct = addressing. Some=20 examples of direct addressing
are:

>     LDA        where DP =3D $00=20
>     LDB         where DP $10=20
>     LDD <CAT

> **NOTE****\
> **\<=20 is an assembler directive which forces direct = addressing.

REGISTER ADDRESSING
-------------------

Some opcodes are followed by a byte that defines a register or set of =
registers to be used by the instruction. This is called a postbyte. Some
= examples of register addressing are:

>     TFR    X, Y        Transfers X into Y
>     EXG A, B        Exchanges A with B=20
>     PSHS    A, B, X, Y      Push Y, X, 8 and A onto S stack
>     PULU    X, Y, D     Pull D, X, and Y from U stack

INDEXED ADDRESSING
------------------

In all indexed addressing, one of the pointer registers (X, Y, U, S, =
and=20 sometimes PC) is used in a calculation at the effective address
of the = operand=20 to be used by the instruction. Five basic types of
indexing are = available and=20 are discussed below. The postbyte of an
indexed instruction specifies = the basic=20 type and variation of the
addressing mode, as well as the pointer = register to be=20 used. Figure
15 lists the legal formats for the postbyte. Table 2 gives = the=20
assembler form and the number of cycles and bytes added to the basic =
values for=20 indexed addressing for each variation.

> **FIGURE. 15 - INDEXED ADDRESSING = POSTBYTE=20 REGISTER BIT
> ASSIGNMENTS**
>
> **Post-byte=20 \
> Register bit**
>
> **Indexed=20 \
> Addressing \
> Mode**
>
> 7
>
> 6
>
> 5
>
> 4
>
> 3
>
> 2
>
> 1
>
> 0
>
> 0
>
> R
>
> R
>
> d
>
> d
>
> d
>
> d
>
> d
>
> EA =3D ,R + 5-bit = offset
>
> 1
>
> R
>
> R
>
> 0
>
> 0
>
> 0
>
> 0
>
> 0
>
> , R++
>
> 1
>
> R
>
> R
>
> i
>
> 0
>
> 0
>
> 0
>
> 1
>
> , -R
>
> 1
>
> R
>
> R
>
> 0
>
> 0
>
> 0
>
> 1
>
> 1
>
> , --R
>
> 1
>
> R
>
> R
>
> i
>
> 0
>
> 1
>
> 0
>
> 0
>
> EA =3D ,R + 0 = offset
>
> 1
>
> R
>
> R
>
> i
>
> 0
>
> 1
>
> 0
>
> 1
>
> EA =3D ,R + ACCB = offset
>
> 1
>
> R
>
> R
>
> i
>
> 0
>
> 1
>
> 1
>
> 0
>
> EA =3D ,R + ACCA = offset
>
> 1
>
> R
>
> R
>
> i
>
> 1
>
> 0
>
> 0
>
> 0
>
> EA =3D ,R + 8-bit = offset
>
> 1
>
> R
>
> R
>
> i
>
> 1
>
> 0
>
> 0
>
> 1
>
> EA =3D ,R + 16-bit = offset
>
> 1
>
> R
>
> R
>
> i
>
> 1
>
> 0
>
> 1
>
> 1
>
> EA =3D ,R + D = offset
>
> 1
>
> x
>
> x
>
> i
>
> 1
>
> 1
>
> 0
>
> 0
>
> EA =3D ,PC + 8-bit = offset
>
> 1
>
> x
>
> x
>
> i
>
> 1
>
> 1
>
> 0
>
> 1
>
> EA =3D ,PC + 16-bit = offset
>
> 1
>
> R
>
> R
>
> i
>
> 1
>
> 1
>
> 1
>
> 1
>
> EA =3D (, Address)
>
>  
>
> |\
> |
>
> |\
> |
>
> |\
> |
>
> |\
> V
>
> |\
> V
>
> |\
> V
>
> |\
> V
>
>  
>
> |
>
> |
>
> V
>
>  
>
> Addressing mode = field
>
> V
>
> V
>
> i
>
> Indirect field (or sign = bit when=20 bit 7 =3D 0)
>
> 0
>
> Direct
>
> 1
>
> Indirect
>
> RR
>
> Register = field
>
> 0
>
> 0
>
> =3D X
>
> 0
>
> 1
>
> =3D Y
>
> 1
>
> 0
>
> =3D U
>
> 1
>
> 1
>
> =3D=20 S

    x =3D Don't Care
    d =3D offset bit
    i =3D 0 =3D Not Indirect=20
        1 =3D Indirect

ZERO-OFFSET INDEXED
-------------------

In this mode, the selected pointer register contains the effective =
address of=20 the data to be used by the instruction. This is the
fastest indexing = mode.=20 Examples are:

>     LDD    0,X=20
>     LDA ,S

CONSTANT OFFSET INDEXED
-----------------------

In this mode, a two's-complement offset and the contents of one of =
the=20 pointer registers are added to form the effective address of the
= operand. The=20 pointer register's initial content is unchanged by the
addition.

Three sizes of offset are available:

> 5-bit (-16 to +15) \
> 8-bit (-128 to +128)\
> 16-bit (-32768 to=20 +32767)

The two's complement 5-bit offset is included in the postbyte and, =
therefore,=20 is most efficient in use of bytes and cycles. The two's
complement 8-bit = offset=20 is contained in a single byte following the
postbyte. The two's = complement=20 16-bit offset is in the two bytes
following the postbyte. In most cases = the=20 programmer need not be
concerned with the size of this offset since the=20 assembler will
select the optimal size automatically. Examples of=20 constant-offset
indexing are:

>     LDA 23,X=20
>     LDX - 2,S=20
>     LDY 300,X=20
>     LDU CAT,Y

TABLE 2 - INDEXED ADDRESSING MODE
---------------------------------

**Type**

**Forms**

**Non-Indirect**

**Indirect**

**Assembler=20 \
Form**

**Postbyte=20 \
Opcode**

**+\
\~**

**+\
\#**

**Assembler=20 \
Form**

**Postbyte\
Opcode**

**+\
\~**

**+\
\#**

Constant Offset From R\
(2's Complement = Offsets)

No Offset

,R

1RR00100

0

0

[,R]

1RR10100

3

0

5-Bit Offset

n,R

0RRnnnnn

1

0

defaults to = 8-bit

8-Bit Offset

n,R

1RR01000

1

1

[n,R]

1RR11000

4

1

16-Bit Offset

n,R

1RR01001

4

2

[n,R]

 

7

2

Accumulator Offset From R \
(2's Complement = Offsets)

A Register Offset

A,R

1RR00110

1

0

[A,R]

1RR10110

4

0

B Register Offset

B,R

1RR00101

1

0

[B,R]

1RR10101

4

0

D Register Offset

D,R

1RR01011

4

0

[D,R]

1RR11011

7

0

Auto Increment/Decrement R

Increment By 1

,R+

1RR00000

2

0

not allowed

Increment By 2

,R++

1RR00001

3

0

[,R++]

1RR10001

6

0

Decrement By 1

,-R

1RR00010

2

0

not allowed

Decrement By 2

,--R

1RR00011

3

0

[,--R]

1RR10011

6

0

Constant Offset From PC\
(2's Complement = Offsets)

8-Bit Offset

n,PCR

1xx01100

1

1

[n,PCR]

1xx11100

4

1

16-Bit Offset

n,PCR

lxx01101

5

2

[n,PCR]

1xx11101

8

2

Extended Indirect

16-Bit Address

-

-

-

-

[n]

1xx11111

5

2

    R =
    =3D X,Y,U or S
    x =3D Don't Care
    RR: 00 =3D X, 01 =3D Y, 10 =3D U, 11 =3D S

**+ \~**and**+\#** indicate the number of = additional=20 cycles and
bytes respectively for the particular indexing variation.

ACCUMULATOR-OFFSET INDEXED
--------------------------

This mode is similar to constant offset indexed except that the two's =
complement value in one of the accumulators (A, B, or D) and the =
contents of one=20 of the pointer registers are added to form the
effective address of the = operand.=20 The contents of both the
accumulator and the pointer register are = unchanged by=20 the addition.
The postbyte specifies which accumulator to use as an = offset and=20 no
additional bytes are required. The advantage of an accumulator offset =
is that=20 the value of the offset can be calculated by a program at
run-time.

Some examples are:

>     LDA    B,Y
>     LDX D,Y
>     LEAX    B,X 

AUTO INCREMENT/DECREMENT INDEXED
--------------------------------

In the auto increment addressing mode, the pointer register contains =
the=20 address of the operand. Then, after the pointer register is used,
it is=20 incremented by one or two. This addressing mode is useful in
stepping = through=20 tables, moving data, or creating software stacks.
In auto-decrement, the = pointer=20 register is decremented prior to use
as the address of the data. The use = of=20 auto-decrement is similar to
that of auto-increment, but the tables. = etc., are=20 scanned from the
high to low addresses. The size of the = increment/decrement can=20 be
either one or two to allow for tables of either 8- or 16-bit data to =
be=20 accessed and is selectable by the programmer. The pre-decrement, =
post-increment=20 nature of these modes allows them to be used to create
additional = software=20 stacks that behave identically to the U and S
stacks.

Some examples of the auto increment/decrement addressing modes are: =

>     LDA    ,X+
>     STD ,Y++
>     LDB ,-Y
>     LDX ,--S 

Care should be taken in performing operations on 16-bit pointer =
registers (X,=20 Y, U, S) where the same register is used to calculate
the effective = address.=20

Consider the following instruction:

>     STX    0,X++ (X initialized to 0)

Tha desired result is to store a zero in locations \$0000 and \$0001, =
then=20 increment X to point to \$0002. In reality, the following
occurs:

>     0   --> temp    calculate the EA; temp is a holding =
>     register=20
>     X+2 --> X    perform auto increment=20
>     X   --> (temp)   do store operation 

INDEXED INDIRECT
----------------

All of the indexing modes, with the exception of auto =
increment/decrement by=20 one or a 16-bit offset, may have an additional
level of indirection = specitied.=20 In indirect addressing, the
effective address is contained at the = location=20 specified by the
contents of the index register plus any offset. In the = example=20
below, the A accumulator is loaded indirectly using an effective address
= calculated from the index register and an offset.

> Before Execution
>
> >     A =3D XX (don't care)=20
> >     X =3D $F000
> >
> >     $0100 LDA [$10,X) EA is now $F010
> >
> >     $F010 =
> >     $F1     $F150 is now the new EA
> >     $F011 $50
> >
> >     $F150 $AA 
>
> After Execution
>
> >     A =3D $AA (actual data loaded)
> >     X =3D $F000

All modes of indexed indirect are included except those which are =
meaningless=20 (e.g, auto increment/decrement by 1 indirect). Some
examples of indexed = indirect=20 are

>     LDA    [,X]
>     LDD [10, S]
>     LDA [B,Y]
>     LDD [,X++]

RELATIVE ADDRESSING
-------------------

The byte(s) following the branch opcode is (are) treated as a signed =
offset=20 which may be added to the program counter. If the branch
condition is = true, then=20 the calculated address (PC + signed offset)
is loaded into the program = counter.=20 Program execution continues at
the new location as indicated by the PC; = short=20 (one byte offset)
and long (two bytes offset) relative addressing modes = are=20
available. All of memory can be reached in long relative addressing as =
an=20 effective address interpreted modulo 2^16^. Some examples of =
relative=20 addressing are:

>        BEQ CAT (short)=20
>         BGT DOG (short)
>     CAT     LBEQ    RAT (long)=20
>     DOG LBGT    RABBIT  (long)
>     .
>     .
>     .
>     RAT NOP
>     RABBIT  NOP

PROGRAM COUNTER RELATIVE
------------------------

The PC can be used as the pointer register with 8- or 16-bit signed =
offsets.=20 As in relative addressing, the offset is added to the
current PC to = create the=20 effective address. The effective address
is then used as the address of = the=20 operand or data. Program counter
relative addressing is used for writing = position independent programs.
Tables related to a particular routine = will=20 maintain the same
relationship after the routine is moved, if referenced = relative to the
program counter. Examples are:

>     LDA    CAT, PCR
>     LEAX    TABLE, PCR

Since program counter relative is a type of indexing, an additional =
level of=20 indirection is available.

>     LDA    [CAT,PCR]
>     LDU [DOG,PCR]
