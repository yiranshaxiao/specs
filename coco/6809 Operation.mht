From: <Saved by Microsoft Internet Explorer 5>
Subject: 6809 Operation
Date: Thu, 15 May 2003 21:54:03 -0700
MIME-Version: 1.0
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.howell1964.freeserve.co.uk/parts/6809_operation.htm
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1165

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>6809 Operation</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2800.1170" name=3DGENERATOR></HEAD>
<BODY bgColor=3D#ffffff>
<H1><FONT color=3D#0000ff>6809 MPU OPERATION</FONT></H1>
<P>During normal operation, the MPU fetches an instruction from memory =
and then=20
executes the requested function. This sequence begins after RESET and is =

repeated indefinitely unless altered by a special instruction or =
hardware=20
occurrence. Software instructions that alter normal MPU operation are: =
SWI,=20
SWI2, SWI3, CWAI, RTI, and SYNC. An interrupt or !HALT input can also =
alter the=20
normal execution of instructions Figure 14 is the flowchart for the =
MC6809E.</P>
<BLOCKQUOTE>
  <P><A =
href=3D"http://www.howell1964.freeserve.co.uk/parts/6809fig10.png"><FONT =

  color=3D#0000ff><STRONG>FIGURE 10 - CLOCK=20
GENERATOR</STRONG></FONT></A></P></BLOCKQUOTE>
<BLOCKQUOTE>
  <P>NOTE: If optional circuit is not included the CLR and PRE inputs of =
U2 and=20
  U3 must be tied high.</P>
  <P><A =
href=3D"http://www.howell1964.freeserve.co.uk/parts/6809fig11"><FONT=20
  color=3D#0000ff><STRONG>FIGURE 11 - READ-MODIFY-WRITE INSTRUCTION =
EXAMPLE (ASL=20
  EXTENDED INDIRECT)</STRONG></FONT></A></P></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>ADDRESSING MODES</FONT></H2>
<P>The basic instructions of any computer are greatly enhanced by the =
presence=20
of powerful addressing modes. The MC6809E has the most complete set of=20
addressing modes available on any microcomputer. For example, the =
MC6809E has 59=20
basic instructions; however, it recognizes 1464 different variations of=20
instructinns and addressing modes. The addressing modes support modern=20
programming techniques. The following addressing modes are available on =
the=20
MC6809E:</P>
<BLOCKQUOTE>
  <P>Inherent (Includes =
Accumulator)<BR>Immediate<BR>Extended<BR>Extended=20
  Indirect<BR>Direct<BR>Register<BR>Indexed<BR>Zero-Offset<BR>Constant=20
  Oftset<BR>Accumulator Qffset<BR>Auto Increment Decrement<BR>Indexed=20
  Indirect<BR>Relative<BR>Short Long Relative Branching<BR>Program =
Counter=20
  Relative Addressing</P></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>INHERENT (INCLUDES ACCUMULATOR)</FONT></H2>
<P>In this addressing mode, the opcode of the instruction contains all =
the=20
address information necessary. Examples of inherent addressing are: ABX, =
DAA,=20
SWI, ASRA, and CLRB.</P>
<H2><FONT color=3D#0000ff>IMMEDIATE ADDRESSING</FONT></H2>
<P>In immediate addressing, the effective address of the data is the =
location=20
immediatelv following the opcode (i.e., the data to be used in the =
instruction=20
immediately following the opcode at the instruction). The MC6809E uses =
both 8-=20
and 16-bit immediate values depending on the size of argument specified =
by the=20
opcode. Examples of instructions with immediate addressing are:</P>
<BLOCKQUOTE><PRE>LDA	#$20
LDX	#$F000
LDY	#CAT</PRE></BLOCKQUOTE>
<BLOCKQUOTE>
  <P>NOTE<BR># signifies immediate addressing; <BR>$ signifies =
hexadecimal value=20
  to the MC6809 assembler.</P></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>EXTENDED ADDRESSING</FONT></H2>
<P>In extended addressing, the contents of the two bytes immediately =
following=20
the opcode fully specify the 16-bit effective address used by the =
instruction.=20
Note that the address generated by an extended instruction defines an =
absolute=20
address and is not position independent. Examples of extended addressing =

include:</P>
<BLOCKQUOTE><PRE>LDA	CAT=20
STX	MOUSE=20
LDD	$2000</PRE></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>EXTENDED INDIRECT</FONT></H2>
<P>As a special case of indexed addressing (discussed below), one level =
of=20
indirection may be added to extended addressing. In extended indirect, =
the two=20
bytes following the postbyte of an indexed instruction contain the =
address of=20
the data.</P>
<BLOCKQUOTE><PRE>LDA	[CAT]
LDX	[$FFFE]
STU	[DOG]</PRE></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>DIRECT ADDRESSING</FONT></H2>
<P>Direct addressing is similar to extended addressing except that only =
one byte=20
of address tollows the opcode. This byte specifies the lower eight bits =
of the=20
address to be used. The upper eight bits of the address are supplied by =
the=20
dira.t page register. Since only one byte of address is required in =
direct=20
addressing, this mode requires less memory and exe-cutes taster than =
extended=20
addressing. Of course. only 256 locations (one page) can be accessed =
without=20
redefining the contents of the DP register. Since the DP register is set =
to $00=20
on reset, direct addressing on the MC6809E is upward compatible with =
direct=20
addressing on the M6800. Indirection is not allowed in direct =
addressing. Some=20
examples of direct addressing are:</P>
<BLOCKQUOTE><PRE>LDA		where DP =3D $00=20
LDB 		where DP $10=20
LDD &lt;CAT</PRE></BLOCKQUOTE>
<BLOCKQUOTE>
  <P><FONT =
color=3D#0000ff><STRONG>NOTE</STRONG></FONT><STRONG><BR></STRONG>&lt;=20
  is an assembler directive which forces direct =
addressing.</P></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>REGISTER ADDRESSING</FONT></H2>
<P>Some opcodes are followed by a byte that defines a register or set of =

registers to be used by the instruction. This is called a postbyte. Some =

examples of register addressing are:</P>
<BLOCKQUOTE><PRE>TFR	X, Y		Transfers X into Y
EXG	A, B		Exchanges A with B=20
PSHS	A, B, X, Y		Push Y, X, 8 and A onto S stack
PULU	X, Y, D		Pull D, X, and Y from U stack</PRE></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>INDEXED ADDRESSING</FONT></H2>
<P>In all indexed addressing, one of the pointer registers (X, Y, U, S, =
and=20
sometimes PC) is used in a calculation at the effective address of the =
operand=20
to be used by the instruction. Five basic types of indexing are =
available and=20
are discussed below. The postbyte of an indexed instruction specifies =
the basic=20
type and variation of the addressing mode, as well as the pointer =
register to be=20
used. Figure 15 lists the legal formats for the postbyte. Table 2 gives =
the=20
assembler form and the number of cycles and bytes added to the basic =
values for=20
indexed addressing for each variation.</P>
<BLOCKQUOTE>
  <P><FONT color=3D#0000ff><STRONG>FIGURE. 15 - INDEXED ADDRESSING =
POSTBYTE=20
  REGISTER BIT ASSIGNMENTS</STRONG></FONT></P>
  <TABLE cellSpacing=3D0 cellPadding=3D3 border=3D1>
    <TBODY>
    <TR>
      <TD align=3Dmiddle colSpan=3D8><FONT =
color=3D#0000ff><STRONG>Post-byte=20
        <BR>Register bit</STRONG></FONT></TD>
      <TD align=3Dmiddle rowSpan=3D2><FONT =
color=3D#0000ff><STRONG>Indexed=20
        <BR>Addressing <BR>Mode</STRONG></FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">7</FONT></TD>
      <TD><FONT face=3D"Courier New">6</FONT></TD>
      <TD><FONT face=3D"Courier New">5</FONT></TD>
      <TD><FONT face=3D"Courier New">4</FONT></TD>
      <TD><FONT face=3D"Courier New">3</FONT></TD>
      <TD><FONT face=3D"Courier New">2</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">d</FONT></TD>
      <TD><FONT face=3D"Courier New">d</FONT></TD>
      <TD><FONT face=3D"Courier New">d</FONT></TD>
      <TD><FONT face=3D"Courier New">d</FONT></TD>
      <TD><FONT face=3D"Courier New">d</FONT></TD>
      <TD><FONT face=3D"Courier New">EA =3D ,R + 5-bit =
offset</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">, R++</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">i</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">, -R</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">, --R</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">i</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">EA =3D ,R + 0 =
offset</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">i</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">EA =3D ,R + ACCB =
offset</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">i</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">EA =3D ,R + ACCA =
offset</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">i</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">EA =3D ,R + 8-bit =
offset</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">i</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">EA =3D ,R + 16-bit =
offset</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">i</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">EA =3D ,R + D =
offset</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">x</FONT></TD>
      <TD><FONT face=3D"Courier New">x</FONT></TD>
      <TD><FONT face=3D"Courier New">i</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">EA =3D ,PC + 8-bit =
offset</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">x</FONT></TD>
      <TD><FONT face=3D"Courier New">x</FONT></TD>
      <TD><FONT face=3D"Courier New">i</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">EA =3D ,PC + 16-bit =
offset</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">R</FONT></TD>
      <TD><FONT face=3D"Courier New">i</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">EA =3D (, Address)</FONT></TD></TR>
    <TR>
      <TD rowSpan=3D10>&nbsp;</TD>
      <TD><FONT face=3D"Courier New">|<BR>|</FONT></TD>
      <TD><FONT face=3D"Courier New">|<BR>|</FONT></TD>
      <TD><FONT face=3D"Courier New">|<BR>|</FONT></TD>
      <TD><FONT face=3D"Courier New">|<BR>V</FONT></TD>
      <TD><FONT face=3D"Courier New">|<BR>V</FONT></TD>
      <TD><FONT face=3D"Courier New">|<BR>V</FONT></TD>
      <TD><FONT face=3D"Courier New">|<BR>V</FONT></TD>
      <TD>&nbsp;</TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">|</FONT></TD>
      <TD><FONT face=3D"Courier New">|</FONT></TD>
      <TD><FONT face=3D"Courier New">V</FONT></TD>
      <TD bgColor=3D#00ff00 colSpan=3D4>&nbsp;</TD>
      <TD><FONT face=3D"Courier New">Addressing mode =
field</FONT></TD></TR>
    <TR>
      <TD rowSpan=3D3><FONT face=3D"Courier New">V</FONT></TD>
      <TD rowSpan=3D3><FONT face=3D"Courier New">V</FONT></TD>
      <TD bgColor=3D#00ff00><FONT face=3D"Courier New">i</FONT></TD>
      <TD colSpan=3D5><FONT face=3D"Courier New">Indirect field (or sign =
bit when=20
        bit 7 =3D 0)</FONT></TD></TR>
    <TR>
      <TD bgColor=3D#00ffff><FONT face=3D"Courier New">0</FONT></TD>
      <TD colSpan=3D5><FONT face=3D"Courier New">Direct</FONT></TD></TR>
    <TR>
      <TD bgColor=3D#00ffff><FONT face=3D"Courier New">1</FONT></TD>
      <TD colSpan=3D5><FONT face=3D"Courier =
New">Indirect</FONT></TD></TR>
    <TR>
      <TD align=3Dmiddle bgColor=3D#00ff00 colSpan=3D2><FONT=20
        face=3D"Courier New">RR</FONT></TD>
      <TD colSpan=3D6><FONT face=3D"Courier New">Register =
field</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD colSpan=3D6><FONT face=3D"Courier New">=3D X</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD colSpan=3D6><FONT face=3D"Courier New">=3D Y</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">0</FONT></TD>
      <TD colSpan=3D6><FONT face=3D"Courier New">=3D U</FONT></TD></TR>
    <TR>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD><FONT face=3D"Courier New">1</FONT></TD>
      <TD colSpan=3D6><FONT face=3D"Courier New">=3D=20
S</FONT></TD></TR></TBODY></TABLE></BLOCKQUOTE><PRE>x =3D Don't Care
d =3D offset bit
i =3D 0 =3D Not Indirect=20
    1 =3D Indirect</PRE>
<H2><FONT color=3D#0000ff>ZERO-OFFSET INDEXED</FONT></H2>
<P>In this mode, the selected pointer register contains the effective =
address of=20
the data to be used by the instruction. This is the fastest indexing =
mode.=20
Examples are: </P>
<BLOCKQUOTE><PRE>LDD	0,X=20
LDA	,S</PRE></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>CONSTANT OFFSET INDEXED</FONT></H2>
<P>In this mode, a two's-complement offset and the contents of one of =
the=20
pointer registers are added to form the effective address of the =
operand. The=20
pointer register's initial content is unchanged by the addition. </P>
<P>Three sizes of offset are available: </P>
<BLOCKQUOTE>
  <P>5-bit (-16 to +15) <BR>8-bit (-128 to +128)<BR>16-bit (-32768 to=20
+32767)</P></BLOCKQUOTE>
<P>The two's complement 5-bit offset is included in the postbyte and, =
therefore,=20
is most efficient in use of bytes and cycles. The two's complement 8-bit =
offset=20
is contained in a single byte following the postbyte. The two's =
complement=20
16-bit offset is in the two bytes following the postbyte. In most cases =
the=20
programmer need not be concerned with the size of this offset since the=20
assembler will select the optimal size automatically. Examples of=20
constant-offset indexing are: </P>
<BLOCKQUOTE><PRE>LDA 23,X=20
LDX - 2,S=20
LDY 300,X=20
LDU CAT,Y</PRE></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>TABLE 2 - INDEXED ADDRESSING MODE</FONT></H2>
<TABLE cellSpacing=3D0 cellPadding=3D3 border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle rowSpan=3D2><FONT=20
    color=3D#0000ff><STRONG>Type</STRONG></FONT></TD>
    <TD align=3Dmiddle rowSpan=3D2><FONT=20
      color=3D#0000ff><STRONG>Forms</STRONG></FONT></TD>
    <TD align=3Dmiddle colSpan=3D4><FONT=20
      color=3D#0000ff><STRONG>Non-Indirect</STRONG></FONT></TD>
    <TD align=3Dmiddle colSpan=3D4><FONT=20
      color=3D#0000ff><STRONG>Indirect</STRONG></FONT></TD></TR>
  <TR>
    <TD align=3Dmiddle><FONT color=3D#0000ff><STRONG>Assembler=20
      <BR>Form</STRONG></FONT></TD>
    <TD align=3Dmiddle><FONT color=3D#0000ff><STRONG>Postbyte=20
      <BR>Opcode</STRONG></FONT></TD>
    <TD align=3Dmiddle><FONT =
color=3D#0000ff><STRONG>+<BR>~</STRONG></FONT></TD>
    <TD align=3Dmiddle><FONT =
color=3D#0000ff><STRONG>+<BR>#</STRONG></FONT></TD>
    <TD align=3Dmiddle><FONT color=3D#0000ff><STRONG>Assembler=20
      <BR>Form</STRONG></FONT></TD>
    <TD align=3Dmiddle><FONT=20
      color=3D#0000ff><STRONG>Postbyte<BR>Opcode</STRONG></FONT></TD>
    <TD align=3Dmiddle><FONT =
color=3D#0000ff><STRONG>+<BR>~</STRONG></FONT></TD>
    <TD align=3Dmiddle><FONT =
color=3D#0000ff><STRONG>+<BR>#</STRONG></FONT></TD></TR>
  <TR>
    <TD rowSpan=3D4>Constant Offset From R<BR>(2's Complement =
Offsets)</TD>
    <TD>No Offset</TD>
    <TD>,<FONT face=3DCourier>R</FONT></TD>
    <TD><FONT face=3DCourier>1RR00100</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD>
    <TD><FONT face=3DCourier>[,R]</FONT></TD>
    <TD><FONT face=3DCourier>1RR10100</FONT></TD>
    <TD><FONT face=3DCourier>3</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD></TR>
  <TR>
    <TD>5-Bit Offset</TD>
    <TD><FONT face=3DCourier>n,R</FONT></TD>
    <TD><FONT face=3DCourier>0RRnnnnn</FONT></TD>
    <TD><FONT face=3DCourier>1</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD>
    <TD colSpan=3D4><FONT face=3DCourier>defaults to =
8-bit</FONT></TD></TR>
  <TR>
    <TD>8-Bit Offset</TD>
    <TD><FONT face=3DCourier>n,R</FONT></TD>
    <TD><FONT face=3DCourier>1RR01000</FONT></TD>
    <TD><FONT face=3DCourier>1</FONT></TD>
    <TD><FONT face=3DCourier>1</FONT></TD>
    <TD><FONT face=3DCourier>[n,R]</FONT></TD>
    <TD><FONT face=3DCourier>1RR11000</FONT></TD>
    <TD><FONT face=3DCourier>4</FONT></TD>
    <TD><FONT face=3DCourier>1</FONT></TD></TR>
  <TR>
    <TD>16-Bit Offset</TD>
    <TD><FONT face=3DCourier>n,R</FONT></TD>
    <TD><FONT face=3DCourier>1RR01001</FONT></TD>
    <TD><FONT face=3DCourier>4</FONT></TD>
    <TD><FONT face=3DCourier>2</FONT></TD>
    <TD><FONT face=3DCourier>[n,R]</FONT></TD>
    <TD>&nbsp;</TD>
    <TD><FONT face=3DCourier>7</FONT></TD>
    <TD><FONT face=3DCourier>2</FONT></TD></TR>
  <TR>
    <TD rowSpan=3D3>Accumulator Offset From R <BR>(2's Complement =
Offsets)</TD>
    <TD>A Register Offset</TD>
    <TD><FONT face=3DCourier>A,R</FONT></TD>
    <TD><FONT face=3DCourier>1RR00110</FONT></TD>
    <TD><FONT face=3DCourier>1</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD>
    <TD><FONT face=3DCourier>[A,R]</FONT></TD>
    <TD><FONT face=3DCourier>1RR10110</FONT></TD>
    <TD><FONT face=3DCourier>4</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD></TR>
  <TR>
    <TD>B Register Offset</TD>
    <TD><FONT face=3DCourier>B,R</FONT></TD>
    <TD><FONT face=3DCourier>1RR00101</FONT></TD>
    <TD><FONT face=3DCourier>1</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD>
    <TD><FONT face=3DCourier>[B,R]</FONT></TD>
    <TD><FONT face=3DCourier>1RR10101</FONT></TD>
    <TD><FONT face=3DCourier>4</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD></TR>
  <TR>
    <TD>D Register Offset</TD>
    <TD><FONT face=3DCourier>D,R</FONT></TD>
    <TD><FONT face=3DCourier>1RR01011</FONT></TD>
    <TD><FONT face=3DCourier>4</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD>
    <TD><FONT face=3DCourier>[D,R]</FONT></TD>
    <TD><FONT face=3DCourier>1RR11011</FONT></TD>
    <TD><FONT face=3DCourier>7</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD></TR>
  <TR>
    <TD rowSpan=3D4>Auto Increment/Decrement R </TD>
    <TD>Increment By 1</TD>
    <TD><FONT face=3DCourier>,R+</FONT></TD>
    <TD><FONT face=3DCourier>1RR00000</FONT></TD>
    <TD><FONT face=3DCourier>2</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD>
    <TD colSpan=3D4><FONT face=3DCourier>not allowed</FONT></TD></TR>
  <TR>
    <TD>Increment By 2</TD>
    <TD><FONT face=3DCourier>,R++</FONT></TD>
    <TD><FONT face=3DCourier>1RR00001</FONT></TD>
    <TD><FONT face=3DCourier>3</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD>
    <TD><FONT face=3DCourier>[,R++]</FONT></TD>
    <TD><FONT face=3DCourier>1RR10001</FONT></TD>
    <TD><FONT face=3DCourier>6</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD></TR>
  <TR>
    <TD>Decrement By 1</TD>
    <TD><FONT face=3DCourier>,-R</FONT></TD>
    <TD><FONT face=3DCourier>1RR00010</FONT></TD>
    <TD><FONT face=3DCourier>2</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD>
    <TD colSpan=3D4><FONT face=3DCourier>not allowed</FONT></TD></TR>
  <TR>
    <TD>Decrement By 2</TD>
    <TD><FONT face=3DCourier>,--R</FONT></TD>
    <TD><FONT face=3DCourier>1RR00011</FONT></TD>
    <TD><FONT face=3DCourier>3</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD>
    <TD><FONT face=3DCourier>[,--R]</FONT></TD>
    <TD><FONT face=3DCourier>1RR10011</FONT></TD>
    <TD><FONT face=3DCourier>6</FONT></TD>
    <TD><FONT face=3DCourier>0</FONT></TD></TR>
  <TR>
    <TD rowSpan=3D2>Constant Offset From PC<BR>(2's Complement =
Offsets)</TD>
    <TD>8-Bit Offset</TD>
    <TD><FONT face=3DCourier>n,PCR</FONT></TD>
    <TD><FONT face=3DCourier>1xx01100</FONT></TD>
    <TD><FONT face=3DCourier>1</FONT></TD>
    <TD><FONT face=3DCourier>1</FONT></TD>
    <TD><FONT face=3DCourier>[n,PCR]</FONT></TD>
    <TD><FONT face=3DCourier>1xx11100</FONT></TD>
    <TD><FONT face=3DCourier>4</FONT></TD>
    <TD><FONT face=3DCourier>1</FONT></TD></TR>
  <TR>
    <TD>16-Bit Offset</TD>
    <TD><FONT face=3DCourier>n,PCR</FONT></TD>
    <TD><FONT face=3DCourier>lxx01101</FONT></TD>
    <TD><FONT face=3DCourier>5</FONT></TD>
    <TD><FONT face=3DCourier>2</FONT></TD>
    <TD><FONT face=3DCourier>[n,PCR]</FONT></TD>
    <TD><FONT face=3DCourier>1xx11101</FONT></TD>
    <TD><FONT face=3DCourier>8</FONT></TD>
    <TD><FONT face=3DCourier>2</FONT></TD></TR>
  <TR>
    <TD>Extended Indirect</TD>
    <TD>16-Bit Address</TD>
    <TD><FONT face=3DCourier>-</FONT></TD>
    <TD><FONT face=3DCourier>-</FONT></TD>
    <TD><FONT face=3DCourier>-</FONT></TD>
    <TD><FONT face=3DCourier>-</FONT></TD>
    <TD><FONT face=3DCourier>[n]</FONT></TD>
    <TD><FONT face=3DCourier>1xx11111</FONT></TD>
    <TD><FONT face=3DCourier>5</FONT></TD>
    <TD><FONT face=3DCourier>2</FONT></TD></TR></TBODY></TABLE><PRE>R =
=3D X,Y,U or S
x =3D Don't Care
RR: 00 =3D X, 01 =3D Y, 10 =3D U, 11 =3D S</PRE>
<P><FONT color=3D#0000ff><STRONG>+ ~ </STRONG></FONT>and<FONT=20
color=3D#0000ff><STRONG> +#</STRONG> </FONT>indicate the number of =
additional=20
cycles and bytes respectively for the particular indexing variation.</P>
<H2><FONT color=3D#0000ff>ACCUMULATOR-OFFSET INDEXED</FONT></H2>
<P>This mode is similar to constant offset indexed except that the two's =

complement value in one of the accumulators (A, B, or D) and the =
contents of one=20
of the pointer registers are added to form the effective address of the =
operand.=20
The contents of both the accumulator and the pointer register are =
unchanged by=20
the addition. The postbyte specifies which accumulator to use as an =
offset and=20
no additional bytes are required. The advantage of an accumulator offset =
is that=20
the value of the offset can be calculated by a program at run-time. </P>
<P>Some examples are:</P>
<BLOCKQUOTE><PRE>LDA	B,Y
LDX	D,Y
LEAX	B,X </PRE></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>AUTO INCREMENT/DECREMENT INDEXED</FONT></H2>
<P>In the auto increment addressing mode, the pointer register contains =
the=20
address of the operand. Then, after the pointer register is used, it is=20
incremented by one or two. This addressing mode is useful in stepping =
through=20
tables, moving data, or creating software stacks. In auto-decrement, the =
pointer=20
register is decremented prior to use as the address of the data. The use =
of=20
auto-decrement is similar to that of auto-increment, but the tables. =
etc., are=20
scanned from the high to low addresses. The size of the =
increment/decrement can=20
be either one or two to allow for tables of either 8- or 16-bit data to =
be=20
accessed and is selectable by the programmer. The pre-decrement, =
post-increment=20
nature of these modes allows them to be used to create additional =
software=20
stacks that behave identically to the U and S stacks. </P>
<P>Some examples of the auto increment/decrement addressing modes are: =
</P>
<BLOCKQUOTE><PRE>LDA	,X+
STD	,Y++
LDB	,-Y
LDX	,--S </PRE></BLOCKQUOTE>
<P>Care should be taken in performing operations on 16-bit pointer =
registers (X,=20
Y, U, S) where the same register is used to calculate the effective =
address.=20
</P>
<P>Consider the following instruction: </P>
<BLOCKQUOTE><PRE>STX	0,X++ (X initialized to 0)</PRE></BLOCKQUOTE>
<P>Tha desired result is to store a zero in locations $0000 and $0001, =
then=20
increment X to point to $0002. In reality, the following occurs: </P>
<BLOCKQUOTE><PRE>0   --&gt; temp	calculate the EA; temp is a holding =
register=20
X+2 --&gt; X	perform auto increment=20
X   --&gt; (temp)	do store operation </PRE></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>INDEXED INDIRECT </FONT></H2>
<P>All of the indexing modes, with the exception of auto =
increment/decrement by=20
one or a 16-bit offset, may have an additional level of indirection =
specitied.=20
In indirect addressing, the effective address is contained at the =
location=20
specified by the contents of the index register plus any offset. In the =
example=20
below, the A accumulator is loaded indirectly using an effective address =

calculated from the index register and an offset. </P>
<BLOCKQUOTE>
  <P>Before Execution</P>
  <BLOCKQUOTE><PRE>A =3D XX (don't care)=20
X =3D $F000</PRE><PRE>$0100 LDA [$10,X)	EA is now $F010</PRE><PRE>$F010 =
$F1		$F150 is now the new EA
$F011 $50</PRE><PRE>$F150 $AA </PRE></BLOCKQUOTE>
  <P>After Execution</P>
  <BLOCKQUOTE><PRE>A =3D $AA (actual data loaded)
X =3D $F000</PRE></BLOCKQUOTE></BLOCKQUOTE>
<P>All modes of indexed indirect are included except those which are =
meaningless=20
(e.g, auto increment/decrement by 1 indirect). Some examples of indexed =
indirect=20
are</P>
<BLOCKQUOTE><PRE>LDA	[,X]
LDD	[10, S]
LDA	[B,Y]
LDD	[,X++]</PRE></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>RELATIVE ADDRESSING</FONT></H2>
<P>The byte(s) following the branch opcode is (are) treated as a signed =
offset=20
which may be added to the program counter. If the branch condition is =
true, then=20
the calculated address (PC + signed offset) is loaded into the program =
counter.=20
Program execution continues at the new location as indicated by the PC; =
short=20
(one byte offset) and long (two bytes offset) relative addressing modes =
are=20
available. All of memory can be reached in long relative addressing as =
an=20
effective address interpreted modulo 2<SUP>16</SUP>. Some examples of =
relative=20
addressing are:</P>
<BLOCKQUOTE><PRE>	BEQ	CAT	(short)=20
	BGT	DOG	(short)
CAT 	LBEQ	RAT	(long)=20
DOG	LBGT	RABBIT	(long)
.
.
.
RAT	NOP
RABBIT	NOP</PRE></BLOCKQUOTE>
<H2><FONT color=3D#0000ff>PROGRAM COUNTER RELATIVE</FONT></H2>
<P>The PC can be used as the pointer register with 8- or 16-bit signed =
offsets.=20
As in relative addressing, the offset is added to the current PC to =
create the=20
effective address. The effective address is then used as the address of =
the=20
operand or data. Program counter relative addressing is used for writing =

position independent programs. Tables related to a particular routine =
will=20
maintain the same relationship after the routine is moved, if referenced =

relative to the program counter. Examples are:</P>
<BLOCKQUOTE><PRE>LDA	CAT, PCR
LEAX 	TABLE, PCR</PRE></BLOCKQUOTE>
<P>Since program counter relative is a type of indexing, an additional =
level of=20
indirection is available.</P>
<BLOCKQUOTE><PRE>LDA	[CAT,PCR]
LDU	[DOG,PCR]</PRE></BLOCKQUOTE></BODY></HTML>
